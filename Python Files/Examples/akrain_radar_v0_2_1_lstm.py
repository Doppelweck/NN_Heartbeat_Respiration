# -*- coding: utf-8 -*-
"""AKRAIN_radar_v0.2.1_LSTM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13smcwThGcuMaPSmW-V3XAwK9XW-VJ0gD

# AKRAIN radar - LSTM
"""

# !pip show tensorflow

import tensorflow as tf
print('tf: ' + tf.__version__)

#install TensorFlow 2.0 alpha version
# !pip install tensorflow==2.0.0-alpha0
!pip install tensorflow-gpu==2.0.0-alpha0

# Commented out IPython magic to ensure Python compatibility.
# Load the TensorBoard notebook extension
# %load_ext tensorboard.notebook

"""Import TensorFlow, datetime, and os:"""

import tensorflow as tf
import datetime, os

"""# Get data file"""

import numpy as np
import pandas as pd
import os

from google.colab import drive

drive.mount('/content/gdrive')

path = "/content/gdrive/My Drive/Colab Notebooks/data/LaROS_radar/AKR"

# filename = os.path.join(path,"akr000")   
# filename = os.path.join(path,"SC_C_002_128_8192_+2019-06-04_13-41+") 
f_30 = os.path.join(path,"train_-30_deg") 
f0 = os.path.join(path,"train_0_deg") 
f30 = os.path.join(path,"train_30_deg") 
# names = ['year', 'month', 'day', 'dec_year', 'sn_value' , 'sn_error', 'obs_num']
# df = pd.read_csv(filename,sep=';',header=None,names=names,na_values=['-1'], index_col=False)

"""read file v 0.1"""

# Create a dtype with the binary data format and the desired column names
dt = np.dtype([('data', 'float64')])

d_30 = np.fromfile(f_30, dtype=dt)
df_30 = pd.DataFrame.from_records(d_30)

d0 = np.fromfile(f0, dtype=dt)
df0 = pd.DataFrame.from_records(d0)

d30 = np.fromfile(f30, dtype=dt)
df30 = pd.DataFrame.from_records(d30)

frames = [df_30, df0, df30]

# print('pre: ' + str(df))

# concatenate all measurement files
df = pd.concat(frames)

# print(df)

# def shuffle(df, n, axis=0):
#         shuffled_df = df.copy()
#         for k in range(n):
#             shuffled_df.apply(np.random.shuffle(shuffled_df.values),axis=axis)
#         return shuffled_df

# df_rnd = shuffle(df, len(df))

# import random

# index = [i for i in range(df.shape[0])]
# random.shuffle(index)
# df.set_index([index]).sort_index()

print('post: ' + str(df))

print(df[0:10])

"""## get input x /output y"""

df_y = df[(df.index+1) % 9 == 0]  # Selects every 8th raw starting from 0

print("Starting df_y:")
print(df_y[0:10])

print("Ending df_x:")
print(df_y[-10:])

df_x = df[(df.index+1) % 9 != 0]  # Excludes every 8th row starting from 0

print("Starting df_x:")
print(df_x[0:10])

print("Ending df_y:")
print(df_x[-10:])

"""reshape data

separete training from test set
"""

# sep = int(len(df) - len(df) * 0.2) # 87612 # data sepration --> 80% train , 20% test

# df_train = df[0:sep]  # Selects a train set  -- ATTN: last index is excluded
# df_val_test  = df[sep::]  # Selects a val-test set

# sep2 = int(len(df_val_test) - len(df_val_test) * 0.5) # val-test set sepration --> 50% val , 50% test

# df_val = df_val_test[0:sep2]
# df_test = df_val_test[sep2::]

"""## v 2.0 - to_sequences"""

# df_y.iloc[0]['data']

"""### merge x & y"""

# merge the channels and the corresponding phase again
# so that the data can be randomly shuffled

def to_8ch_1phase(df_x, df_y):

    n_ch = 8
    df_y.reset_index(drop=True, inplace = True)

    # df_y = df_y[0:10] # TEST

    index = range(0, len(df_y))
    columns = ['ch1','ch2', 'ch3','ch4', 'ch5','ch6', 'ch7','ch8', 'phase']
    rd = pd.DataFrame(index=index, columns=columns)

    for i, row in df_y.iterrows():

        seq = int(i*n_ch)
        # print(str(i) + ': '+ str(row['data']))
        # rd.loc[i] = [i,i,i,i,i,i,i,i, df_y.iloc[i]['data']]
        # rd.loc[len(rd)] = [1,2,3,4,5,6,7,8, df_y.iloc[i]['data']]
        rd.iloc[i] = [df_x.iloc[seq]['data'],df_x.iloc[seq+1]['data'],df_x.iloc[seq+2]['data'],df_x.iloc[seq+3]['data'],df_x.iloc[seq+4]['data'],df_x.iloc[seq+5]['data'],df_x.iloc[seq+6]['data'],df_x.iloc[seq+7]['data'], df_y.iloc[i]['data']]

    return rd
# del rd
rd =  to_8ch_1phase(df_x, df_y)

rd.iloc[:10]

rd

"""## # random shuffle"""

# random shuffle the measuremtents
shulled_idx1 = np.random.permutation(rd.index)
rd = rd.reindex(shulled_idx1)

# reset index
rd.reset_index(drop=True, inplace = True)

# rd.iloc[:10]

"""## separate x & y"""

# separate the channels and the corresponding phase again
rd_x = rd.iloc[:,0:8]
rd_y = rd.iloc[:,8]

# x = rd_x.to_numpy()
# y = rd_y.to_numpy()

x = rd_x[:].values.tolist()
y = rd_y[:].values.tolist()


# change the array to LSTM compatible format
x = np.array([[[j] for j in i] for i in x])
y = np.array([[k] for k in y])

sep = int(len(y) - len(y) * 0.2) # 87612 # data sepration --> 80% train , 20% test

x_train = x[0:sep]  # Selects a train set  -- ATTN: last index is excluded
x_val_test  = x[sep::]  # Selects a test set

y_train = y[0:sep]  # Selects a train set  -- ATTN: last index is excluded
y_val_test  = y[sep::]  # Selects a test set

sep2 = int(len(y_val_test) - len(y_val_test) * 0.5) # val-test set sepration --> 50% val , 50% test

x_val = x_val_test[0:sep2]
x_test = x_val_test[sep2::]

y_val = y_val_test[0:sep2]
y_test = y_val_test[sep2::]

print("Shape of x_training set: {}".format(x_train.shape))
print("Shape of x_test set: {}".format(x_val.shape))
# print(' ')
# print("Shape of y_training set: {}".format(x_train.shape))
# print("Shape of y_test set: {}".format(x_test.shape))

print(x_train[0:10])
print(y_train[0:10])

"""# Tensorboard"""

logdir = os.path.join("logs", datetime.datetime.now().strftime("%Y%m%d-%H%M%S"))
  tensorboard_callback = tf.keras.callbacks.TensorBoard(logdir, histogram_freq=1)

# Commented out IPython magic to ensure Python compatibility.
# %tensorboard --logdir logs

"""# LSTM model -  in Keras and TensorFlow"""

from tensorflow.keras.preprocessing import sequence
from tensorflow.keras.models import Sequential  # Class Sequential Linear stack of layers.
from tensorflow.keras.layers import Dense, Embedding
from tensorflow.keras.layers import LSTM
from tensorflow.keras.datasets import imdb
from tensorflow.keras.callbacks import EarlyStopping
import numpy as np

print('Build model...')
model = Sequential()
model.add(LSTM(64, dropout=0.0, recurrent_dropout=0.0,input_shape=(None, 1)))
model.add(Dense(32))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')
monitor = EarlyStopping(monitor='val_loss', min_delta=1e-3, patience=5, verbose=1, mode='auto', restore_best_weights=True)
print('Train...')

model.fit(x_train,y_train,validation_data=(x_val,y_val),callbacks=[monitor, tensorboard_callback],verbose=2,epochs=1000)
# model.fit(x_train,y_train,validation_data=(x_test,y_test),verbose=2,epochs=1000)

from sklearn import metrics

pred = model.predict(x_test)
score = np.sqrt(metrics.mean_squared_error(pred,y_test))
print("Score (RMSE): {}".format(score))

# print("Starting:")
# print(x_test[0:1])
# print(pred[0:1])

# print("Ending:")
# print(x_test[-1:])
# print(pred[-1:])

pred.shape

tx = np.squeeze(x_test, axis=2)
# t = np.transpose(tx)
tx.shape

ty = y_test
# ty

index = range(0, len(x_test))
columns = ['ch1','ch2', 'ch3','ch4', 'ch5','ch6', 'ch7','ch8', 'phase', 'g-true']
res = pd.DataFrame(index=index, columns=columns)

res.iloc[:,0:8] = tx
res.iloc[:,8]   = pred
res.iloc[:,9]   = ty

# for i in range(len(pred)):
#     res.loc[i] = [i,i,i,i,i,i,i,i, df_y.iloc[i]['data']]


# print(res)

res

